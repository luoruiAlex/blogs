## 面向对象设计原则
* 开闭原则（目的）
* 里氏代换原则（基础）
* 依赖倒转原则（手段）
* 单一职责原则
* 接口隔离原则
* 合成复用原则
* 迪米特法则

## 模式分类
### 创建型模式
- 简单工厂模式、工厂模式、抽象工厂模式(产品族)
- 单例模式
- 构建者模式
- 原型模式(Cloneable接口，clone()方法)
### 结构型模式
- 代理模式
- 适配器模式
- 桥接模式
- 装饰模式
- 门面模式
- 组合模式
- 享元模式
### 行为型模式
- 策略模式
- 观察者模式
- 责任链模式
- 模板方法模式
- 迭代器模式
- 命令模式
- 状态模式
- 备忘录模式
- 访问者模式
- 中介者模式
- 备忘录模式
- 解释器模式

## 代理模式和适配器模式
- 都需要持有具体实现类的实例
- 代理模式用于控制实际对象的访问，有继承关系
- 适配器模式用于适配，没有继承关系

## 代理模式和装饰器模式
- 代理模式用关于控制注实际对象的访问，代理对象和真实对象之间的的关系通常在编译时就已经确定了，通常在代理类中创建实际对象的实例
- 装饰器模式关注于在一个对象上动态的添加方法，通常将原始对象作为参数传入装饰者的构造

## 桥接模式
- 用于有多个变化维度的系统的解耦
- 抽象类持有接口的引用

## 门面模式
- 为系统中多个复杂的接口提供一个统一的访问接口，以简化使用
- 调用一个接口相当于依次访问了多个内部子接口

## 组合模式
- 用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性，比如目录和文件
- Component Leaf Composite(持有List\<Component\>)

## 享元模式
- 分离变(外部状态)与不变(内部状态)，并共享不变

## 策略模式
- 客户端依赖于策略接口，根据不同的实现使用不同的算法

## 观察者模式
- 主题持有每个观察者的引用，数据变更时通知所有观察者

## 责任链模式
- 单向链表，启动前先组合好责任链的顺序(a.setNext(b))，调用头部节点即可，后续自动流转

## 状态模式
- Context对象持有state的引用，把不同状态的操作分散到不同的状态对象里去完成
