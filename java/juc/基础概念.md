## 中断机制
- 只是一种协作机制，即轮询中断标志
- 每个线程有一个interrupt flag，A线程中的代码想中断B线程只能设置B线程的interrupt flag，是否真的中断只能看B线程是否响应该标志
- static boolean interrupted() 返回**当前线程**中断状态，同时**清除中断标志**
- boolean isInterrupted() 线程是否已中断
- void interrupt() 设置该线程的中断标志
  - 无论如何都会设置中断标志
  - 如果阻塞在可中断的I/O上，调用I/O对象的interrupt()方法，中断I/O
    - 阻塞在wait sleep join上，清除中断标志，抛出InterruptedException异常
    - 阻塞在InterruptibleChannel上，chanel关闭，设置中断标志，线程抛出ClosedByInterruptException异常
    - 阻塞在Selector中，设置中断标志，线程立刻返回
- 中断异常的处理：基础类不能吞掉异常(只catch而不做任何事，让上层调用感知不到中断)
  - 让异常直接抛出
  - 在catch子句中，调用Thread.currentThread.interrupt()来设置中断状态（因为抛出异常后中断标示会被清除），让外界通过判断Thread.currentThread().isInterrupted()标示来决定是否终止线程还是继续下去
