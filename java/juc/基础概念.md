## 中断机制
### 原理
- 只是一种协作机制，即轮询中断标志
- 每个线程有一个interrupt status，A线程中的代码想中断B线程只能设置B线程的interrupt status，是否真的中断只能看B线程是否响应该标志
- static boolean interrupted() 返回**当前线程**中断状态，同时**清除中断标志**
- boolean isInterrupted() 线程是否已中断
- void interrupt() 设置该线程的中断标志
  - 无论如何都会设置中断标志
  - 如果阻塞在可中断的I/O上，调用I/O对象的interrupt()方法，中断I/O
### 中断异常的处理：基础类不能吞掉异常(只catch而不做任何事，让上层调用感知不到中断)
  - 让异常直接抛出
  - 在catch子句中，调用Thread.currentThread.interrupt()来设置中断状态（因为抛出异常后中断标示会被清除），让外界通过判断Thread.currentThread().isInterrupted()标示来决定是否终止线程还是继续下去
### 阻塞
- 阻塞线程对中断的响应
  - 阻塞在wait sleep join(会不断的轮询监听 interrupted 标志位)上，提前结束阻塞状态，抛出InterruptedException异常
  - 传统I/O，不会响应中断，不过，调用Socket的close方法后，被阻塞线程会抛出SocketException异常。
  - 阻塞在InterruptibleChannel上，chanel关闭，设置中断标志，线程抛出ClosedByInterruptException异常
  - 阻塞在Selector实现的异步I/O，设置中断标志，线程抛出ClosedSelectorException
- 不可中断的操作
  - 包括进入synchronized段以及Lock.lock()，inputSteam.read()等，调用interrupt()对于这几个问题无效，因为它们都不抛出中断异常。如果拿不到资源，它们会无限期阻塞下去
