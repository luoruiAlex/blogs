## 并发问题
- 重排
  - 编译器优化
  - 指令重排
  - 内存系统重排
- 内存可见性
  - 所有的共享变量存在于主内存中
  - 每个线程有自己的本地内存
- 原子性
  - 对引用的读写永远是原子性的
  - 64位的值的写，可分为2个32位写
   
## happens-before
- x happens-before y，并不是说 x 操作一定要在 y 操作之前被执行，而是说 x 的执行结果对于 y 是可见的，只要满足**可见性**，发生了重排序也是可以的
- volatile变量的写在读前面
- 解锁必然在随后的加锁前
- A先于B，B先于C，则A必然先于C
- 线程的start()先于它的每一个动作
- 线程的所有操作先于线程的终结(Thread.join())
- 线程的中断先于被中断线程的代码
- 对象的构造函数执行、结束先于finalize()方法

## volatile
- 内存可见性
- 禁止指令重排
- volatile 提供了 happens-before 保证，对 volatile 变量 v 的**写入** happens-before 所有其他线程后续对 v 的**读**操作
- 与synchronized相比，没有原子性和互斥性

## final
- final引用不能从构造函数内“逸出”
- 在**构造函数**内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
- 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。
- 写final域的重排序规则禁止把final域的写重排序到构造函数之外
  - JMM禁止编译器把final域的写重排序到构造函数之外。
  - 编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。
- 写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障
- 读final域的重排规则
  - 在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障
- 读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用
- 对于引用类型
  - 在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
