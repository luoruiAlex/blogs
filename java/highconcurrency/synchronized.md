## 对象头
- Mark Word总共32Bit
  - 25Bit对象的HashCode
  - 4Bit对象的分代年龄
  - 1bit是否偏向锁
  - 2bit锁标志位
- 锁标志位变化：
  - 00为轻量级锁，前面30位为指向锁记录的指针
  - 10为重量级锁，前面30位为指向重量级锁的指针
  - 11为GC标记，前面30位为空
  - 01为无锁或者偏向锁
    - 偏向锁：1，前面29为**23位线程ID** \+ **2位Epoch** \+ **4位对象的分代年龄**
    - 无锁：0，  前面为**25位对象的HashCode** \+ **4位对象的分代年龄**
    
## 锁的类型
- 锁的状态：无锁状态 偏向锁状态 轻量级锁状态 重量级锁状态
- 偏向锁：
  - 大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁，减少不必要的CAS操作
  - 获取锁：
    - (1)检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01
    - (2)若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）
    - (3)如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）
    - (4)通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块
    - (5)执行同步代码块
  - 释放锁：偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）
    - 暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态
    - 撤销偏向锁，恢复到无锁状态（01）或者轻量级锁的状态
  - 膨胀：当前线程执行CAS获取偏向锁失败，表示在该锁对象上存在竞争并且这个时候另外一个线程获得偏向锁所有权
    
## Monitor
- Monitor 是线程私有的数据结构，每一个线程都有一个可用**monitor record列表**，同时还有一个**全局的可用列表**
- 每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址）
- monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用
  - Owner:初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL
  - EntryQ:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程
  - RcThis:表示blocked或waiting在该monitor record上的所有线程的个数
  - Nest:用来实现重入锁的计数
  - HashCode:保存从对象头拷贝过来的HashCode值（可能还包含GC age）
  - Candidate:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁
