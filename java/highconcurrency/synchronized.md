## 对象头(Mark word \+ Klass Pointer)
- Mark Word总共32Bit
  - 25Bit对象的HashCode
  - 4Bit对象的分代年龄
  - 1bit是否偏向锁
  - 2bit锁标志位
- 锁标志位变化：
  - 00为轻量级锁，前面30位为指向锁记录的指针
  - 10为重量级锁，前面30位为指向重量级锁的指针
  - 11为GC标记，前面30位为空
  - 01为无锁或者偏向锁
    - 偏向锁：1，前面29为**23位线程ID** \+ **2位Epoch(偏向时间戳)** \+ **4位对象的分代年龄**
    - 无锁：0，  前面为**25位对象的HashCode** \+ **4位对象的分代年龄**
- 64位虚拟机
  - 结尾8bit都是分代年龄 \+ 偏向锁标志 \+ 锁标志
  - 无锁 25bit unused \+ 31bit hashcode
  - 偏向锁 54bit \+ 2bit Epoch
    
## 锁的类型
- 锁的状态：无锁状态 偏向锁状态 轻量级锁状态 重量级锁状态
- 偏向锁：
  - 大多数情况下**锁不仅不存在多线程竞争，而且总是由同一线程多次获得**，为了让线程获得锁的代价更低而引入了偏向锁，减少不必要的CAS操作
  - 获取锁：
    - (1)检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01
    - (2)若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）
    - (3)如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）
    - (4)通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块
    - (5)执行同步代码块
  - 释放锁：偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）
    - 暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态
    - 撤销偏向锁，恢复到无锁状态（01）或者轻量级锁的状态
  - 膨胀：当前线程执行CAS获取偏向锁失败，表示在该锁对象上存在竞争并且这个时候另外一个线程获得偏向锁所有权
- 轻量级锁
  - 真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态（即单线程执行环境），在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中**只需要依靠一条CAS原子指令就可以完成锁的获取及释放**
  - 获取锁：
    - (1)判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在**当前线程的栈帧**中建立一个名为**锁记录（Lock Record）**的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；
    - (2)JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；
    - (3)判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态
  - 释放锁：
    - (1)取出在获取轻量级锁保存在Displaced Mark Word中的数据
    - (2)用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）
    - (3)如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程
  - 膨胀：对象处于膨胀状态同时Owner不为NULL(被锁住)，**在调用操作系统的重量级的互斥锁之前先自旋一定的次数，当达到一定的次数时如果仍然没有成功获得锁，则开始准备进入阻塞状态**
- 重量级锁
  - 通过对象**内部的监视器（monitor）**实现，其中monitor的本质是依赖于底层操作系统的**Mutex Lock**实现，操作系统实现线程之间的切换需要从**用户态**到**内核态**的切换，切换成本非常高
  - 为了减少有限资源的访问和使用冲突，对不同的操作赋予不同的执行等级，就是所谓特权的概念。很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程
- 对比
  - 偏向锁：加锁解锁不需要额外的消耗，和执行非同步方法比较仅存在纳秒级的差距。如果线程间有锁竞争，会带来额外的所撤销的消耗。适用于只有一个线程访问同步块的场景
  - 轻量级锁：竞争的线程不会阻塞，同步块执行速度非常快。如果始终得不到锁竞争的线程，使用自旋会消耗CPU。适用于追求响应时间的场景。
  - 重量级锁：线程竞争无自旋，不消耗CPU，同步块执行速度较快。线程阻塞，响应时间慢。适用于追求吞吐量的场景。
  
## 锁优化：
 - 自旋锁：线程的阻塞和唤醒需要CPU从**用户态转为核心态**，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作。在许多应用上面，对象锁的**锁状态只会持续很短一段时间**。
  - 所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，执行一段无意义的循环即可（自旋），看持有锁的线程是否会很快释放锁
  - 自旋的默认次数为10次，可通过`-XX:PreBlockSpin`来调整
- 自适应自选锁
  - 自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定
  - 线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多
  - 如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。 
- 锁消除：有时候调用的API带锁，开发人员不清楚，JVM通过逃逸分析来消除锁
- 锁粗化：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。比如将锁的操作挪到for循环外面
    
## Monitor
- Monitor 是线程私有的数据结构，每一个线程都有一个可用**monitor record列表**，同时还有一个**全局的可用列表**
- 每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址）
- monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用
  - Owner:初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL
  - EntryQ:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程
  - RcThis:表示blocked或waiting在该monitor record上的所有线程的个数
  - Nest:用来实现重入锁的计数
  - HashCode:保存从对象头拷贝过来的HashCode值（可能还包含GC age）
  - Candidate:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁
