## 服务设计原则
### 服务化
- 以服务、资源、数据为中心，构建服务架构。所有服务可视、可管、可控。
### 服务自制
- 功能原子化，接口契约化，服务自治、自组织及独立演进
- 服务独立交付
  - 服务是独立进行部署、版本控制和管理的实体，服务有自己的版本号，可独立对外发布、安装和运行
- 服务并行安装
  - 服务并行安装，无安装顺序依赖关系。服务发布包之间不允许存在绝对路径相同的文件，即服务之间不能有文件覆盖。
- 服务并行启停
  - 服务启动/停止时无依赖关系，服务启动/停止时不得依赖其他服务，即不得在启动/停止过程中假定运行时所依赖的服务已启动/停止
- 单一职责原则
  - 业务完整性 完成单一的业务职责
  - 变更频度一致性 服务内的功能变更频度是相同的，经常变更的功能划分为独立服务，避免影响服务的整体可用性
  - 可靠性/可扩展性/性能要求一致性 不同要求的可拆分为不同的服务
- 服务数据库去中心化
  - 服务有自己独立的数据库(非数据库实例)，数据库的数据只运行服务自身访问，不允许暴露给其他服务。服务的实现者可选择自身业务的数据库类型
- 服务能力扩展/定制自制
  - 服务不得提供代码注入方式(如插件)对服务能力进行扩展，仅能提供配置方式对现有服务能力进行定制。定制方式通过新增文件的方式修改定制项(文件中只包含定制项)
### 服务无状态
- 业务处理逻辑与数据分离原则，除数据存储外，应用无状态
- 数据不写入本地文件系统
  - 除Trace和临时数据外不能写本地文件，因为本地文件系统中的数据是无法在服务的不同实例间共享的。需要共享的数据(包括但不限于：服务配置、业务数据)需要存储数据到存储服务中(如MySQL、Redis等)
- HTTP会话数据共享
  - 会话数据要能在不同实例节点间共享，以保障一个实例节点的失效不会导致会话数据的丢失，会话数据相关的事务能够在其他的实例来完成
- 支持多实例集群部署
  - 集群方式以无中心节点的无状态对等集群为首选，任意实例节点的失效对整个集群的运行没有影响
- 部署、升级过程可重入
  - 服务在部署、升级阶段提供的业务处理脚本需要支持可冲入能力，即脚本被多次调用可得到相同的结果
### 弹性伸缩
- 支持按需使用资源，服务提供弹性、线性伸缩能力
### 中立原则
- 各个服务可自由选择编程语言、编程框架来实现，可以选择所依赖的中间件、数据库、操作系统，一个服务的选择对其他服务无感知
### 可控原则
- 服务请求通过请求负载均衡器转发，以支持基于策略的灰度发布、导流、异常控制等
### 服务接口稳定
- 已发布的服务接口要保持稳定，接口变更符合统一的兼容性管理要求(跨1-3个V/R版本后向兼容)
