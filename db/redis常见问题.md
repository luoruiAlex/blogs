## 优缺点
- 优点
  - 提升性能，对于执行耗时长而且结果不频繁变动的SQL，适合将结果放入Redis缓存
  - 并发，大并发时所有请求直接访问数据库会导致数据库出现连接异常
- 缺点
  - 缓存和数据库双写一致性问题
  - 缓存雪崩问题
  - 缓存击穿问题
  - 缓存的并发竞争问题
  
## 为什么这么快
- 纯内存操作
- 单线程操作，避免了频繁的上下文切换
- 采用了非阻塞I/O多路复用机制

## 数据类型
- 5种类型
- String：做一些复杂的计数功能的缓存
- hash：能方便地操作结构化对象的某个字段，比如登录时的用户信息
- list：简单的队列功能；利用lrange做高性能分页功能；生产者消费者
- set：全局去重
- sorted set：可做排行榜、TOP N之类的操作

## 过期策略、内存淘汰策略
- 1、定期删除：默认每100ms随机检查是否有过期的key，有就删除
- 2、惰性删除：获取key的时候，redis检查下，如果设置了过期时间而且过期则删除
- 3、内存淘汰机制：内存不足时按照redis.conf中的配置 maxmemory-policy volatile-lru来处理
  - noeviction：新写入报错
  - allkeys-lru：移除最近最少使用的key，推荐
  - allkeys-random：随机删除某个key
  - volatile-lru：删除最近最少使用的设置了过期时间的key，适用于即把redis当缓存又做持久化存储的时候用
  - volatile-random：随机删除设置了过期时间的key
  - volatile-ttl：删除时间更早的过期时间的key
- 为什么不用定时删除，专门用一个定时器来检视key，太耗费CPU

## redis和数据库的双写一致性问题
- 最终一致性、强一致性：有强一致性要求的数据，不能放缓存
- 最终一致性：采取正确的更新策略：先更新数据库，再删缓存；可能存在删除缓存失败的问题，提供补偿措施，比如采用消息队列

## 缓存穿透
- 查询一个一定不存在的数据，从db查不到数据则不写入缓存，则每次请求这个数据时都到db去查询
- 解决办法:
  - 1.利用互斥锁，缓存失效则先去获取锁，得到锁了再去请求数据库，否则休眠一段时间重试
  - 2.采用异步更新策略，无论是否取到值，都直接返回，value中维护一个缓存失效时间，如果缓存过期，则异步起一个线程去读数据库，更新缓存。
  - 3.提供一个能迅速判断请求是否有效的机制，比如布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉
  - 把查询返回空的结果也缓存，但它的过期时间很短
  
## 缓存雪崩
- 一批key同时过期，同时一大批请求全部转发到db，瞬间把db压垮
- 解决办法
  - 1.加锁或者队列的方式保证缓存的单线程写，该方案会使得吞吐量明显现金
  - 2.错开缓存失效时间，比如在固定失效时间上加一个随机值
  - 3.双缓存，缓存A的失效时间为20分支，缓存B不设置失效时间，自己做缓存预热操作
  
## 缓存击穿
- 某个key缓存过期的时候，恰好有大量针对这个key的请求并发过来，这些请求会从db加载数据，大量请求有可能瞬间把db压垮
- 解决办法
  - 使用互斥锁mutex，即缓存失效的时候，不立即load db，而是先试试SETNX，先set 一个mutex key，操作成功返回时，再进行load db的操作并设置缓存

## 布隆过滤器
-  特点：能准确判断一个元素不在集合内，只能判断一个元素可能在集合内；普通布隆过滤器只能增加元素，增强的可以删除元素
- 不适用"零错误"的场景
- 可用一个bit标识多个元素是否存在

##　Bitmap
- 用bit位标示数据是否存在
- 空间不随元素个数的增加而增加，但是随最大元素的增长而增大

## 使用场景
- 缓存热数据
- 计数器 INCR，单线程可避免并发问题
- 队列
  - 简单的消息系统，如果对数据一致性要求高，建议用RocketMQ等系统
  - 把并发请求变成串行
- 位操作(大数据处理) setbit getbit bitcount
- 分布式锁与单线程机制
  - 验证前端的重复请求
  - 秒杀系统(基于Redis的单线程特征)
  - 全局增加ID生产
- 最新列表 LPUSH构建list
- 排行榜 ZADD
