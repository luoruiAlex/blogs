## 缓存穿透
- 查询一个一定不存在的数据，从db查不到数据则不写入缓存，则每次请求这个数据时都到db去查询
- 解决办法:
  - 布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉
  - 把查询返回空的结果也缓存，但它的过期时间很短
  
## 缓存雪崩
- 一批key同时过期，请求全部转发到db，瞬间把db压垮
- 解决办法
  - 加锁或者队列的方式保证缓存的单线程写
  - 错开缓存失效时间，比如在固定失效时间上加一个随机值
  
## 缓存击穿
- 某个key缓存过期的时候，恰好有大量针对这个key的请求并发过来，这些请求会从db加载数据，大量请求有可能瞬间把db压垮
- 解决办法
  - 使用互斥锁mutex，即缓存失效的时候，不立即load db，而是先试试SETNX，先set 一个mutex key，操作成功返回时，再进行load db的操作并设置缓存

## 布隆过滤器
-  特点：能准确判断一个元素不在集合内，只能判断一个元素可能在集合内；普通布隆过滤器只能增加元素，增强的可以删除元素
- 不适用"零错误"的场景
- 可用一个bit标识多个元素是否存在

##　Bitmap
- 用bit位标示数据是否存在
- 空间不随元素个数的增加而增加，但是随最大元素的增长而增大

## 使用场景
- 缓存热数据
- 计数器 INCR，单线程可避免并发问题
- 队列
  - 简单的消息系统，如果对数据一致性要求高，建议用RocketMQ等系统
  - 把并发请求变成串行
- 位操作(大数据处理) setbit getbit bitcount
- 分布式锁与单线程机制
  - 验证前端的重复请求
  - 秒杀系统(基于Redis的单线程特征)
  - 全局增加ID生产
- 最新列表 LPUSH构建list
- 排行榜 ZADD
