### 栈
- 特点：LIFO
- top 栈顶指针
- maxSize 栈容量
- arr\[\] 栈元素
- push() 入栈
- pop() 出栈
- peek() 读取栈顶元素而不移除

### 队列
- 特点：FIFO
- 插入(put add enque)
- 删除(delte get deque)
- 插入队首(head)
- 插入队尾(back tail end)
- 指针(front rear)
- 循环队列：避免队列未满而不能插入新数据项
  - 队尾插入(rear == maxSize - 1则rear=-1)
  - 队首移除(front == maxSize则front=0)

### 链表
- 单链表：有头结点的引用
- 双端链表：有头结点和尾节点的引用
- 双向列表：沿链表反向遍历容易(不必是双端链表，但是双端链表好处更多)

### 二叉树
- 有序数组中插入数据太慢，链表查找太慢，二叉树既能快速插入和删除又能快速查找
- 操作复杂度O(logN)
- 术语
  - 路径：一个节点到另一个节点经过的节点的顺序排序
  - 根：树顶端的节点
  - 父节点
  - 子节点
  - 叶节点
  - 子树
  - 访问(某个节点)
  - 遍历(所有节点)
  - 层(0 1 2 ...)
  - 关键字(节点对象的某个数据域)
  - 二叉树(每个节点最多有2个子节点)
- 封装：Node(key, data, leftChild, rightChild)
- 遍历
  - 中序遍历：升序遍历
    - 调用自身遍历左子树
    - 访问这个节点
    - 调用自身遍历右子树
  - 前序遍历/后序遍历：分析、解析代数表达式很有用
- 删除操作最复杂
  - 该节点没有子节点：直接删除
  - 有1个子节点：用该子节点替换该节点
  - 有2个子节点：用该节点的后继节点(右子节点的一直往左下的后代节点)替换
- 哈夫曼节点(Huffman)编码
  - 二叉树不 一定是搜索树，还可用于编码压缩数据
  
### 红黑树
- 用于保证二叉树的操作复杂度为O(logN)，保证从根到叶子的最长路径不会超过最短路径的2倍
- 规则
  - 每个节点不是红的就是黑的
  - 根总是黑的
  - 叶子节点都是黑色的空节点(NIL节点)
  - 如果节点是红的，那它的子节点必须是黑的
  - 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点
- 插入和删除节点需要调整，方法包括变色和旋转(左旋、右旋)
  - Y为X的右子节点，以X为中心左旋
    - X的右子树绕X逆时针旋转，使X的右子树成为X的父亲
    - X的新的右子树为原来右子树的左子树
- 插入后调整
  - 插入根节点，设置为黑色
  - 父节点为黑色，不需要调整
  - 父节点为红色，**叔叔节点为红色**，将父辈变成黑色，祖辈变成红色，递归向上调整
  - 父节点为红色，**叔叔节点为黑色，本节点为右子节点**，对本节点进行左旋，然后按照下一步调整
  - 父节点为红色，**叔叔节点为黑色，本节点为左子节点**，对祖父节点右旋
- 删除后调整：如果有2个子节点，则要用前驱节点(左子树的最大节点)或者后继节点(右子树的最小节点)替换，简化成只有一个子节点的删除
  - 比插入更复杂，建议用标记删除的方式来实现
  
### 2-3-4树
- 非叶子节点的子节点数总是比它含有的数据项多一个(数据项最少一个，所以子节点最少有2个)
- 0-2给数据项(习惯上升序)编号，0-3给子节点编号
- 数据项的和子节点的数据项的排序也是左小右大，一般不允许出现重复值
- 插入
  - 节点分裂：把数据向上和向右移动
- 2-3-4树发展成为了红黑树，可转换成红黑树
- 效率log(N+1)和log(N+1)/2之间，性能比红黑树略高，但是存储有浪费

### 哈希表
- 哈希冲突
  - 开发地址法
    - 线性探测：有原始聚集的问题
    - 二次探测：步骤是步数的平方，有二次聚集的问题
    - 再哈希法：和第一个哈希函数不同，而且不能输出0
  - 链地址法
  
### 堆
- 堆实现的优先级队列的插入和删除的时间复杂度都是O(logN)
- 特点
  - 完全二叉树(除最后一层外每一层都是满的)
  - 常常用数组实现
  - 每个节点的key都大于等于子节点的关键字
- 插入(使用向上筛选)
  - 先插入到数组最后一个空着的单元中，数组容量增一
  - 向上筛选新节点并交换，直到在一个大于它的节点之下，在一个小于它的节点之上(不是真的交换，而是依次覆盖)
- 移除(删除关键字最大的节点)
  - 删除根节点
  - 把最后一个节点移动到根的位置
  - 一直向下筛选节点，直到它在一个大于它的节点之下，在一个小于它的节点之上(如果有两个子节点，则选择大的那个上移)
