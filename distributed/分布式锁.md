### 要求
- 可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行
- 可重入(避免死锁)
- 阻塞(根据业务需求考虑要不要这条)
- 公平锁(根据业务需求考虑要不要这条)
- 有高可用的获取锁和释放锁功能
- 获取锁和释放锁的性能要好

### 基于数据库的分布式锁
#### 乐观锁
- 基于表主键唯一做分布式锁：成功就插入记录，解锁时删除记录
  - 依赖数据库的可用性：数据库HA
  - 没有失效时间，解锁失败则记录一直留在数据库中：定时清理超时数据
  - 非阻塞：while循环直至insert成功再返回
  - 非重入：记录中记录当前获得锁的主机信息和线程信息
  - 非公平：中间表记录等待锁的线程，根据创建时间排序
  - 主键冲突可能导致锁表现象：在程序中产生主键进行防重
- 基于表字段版本号做分布式锁
  - 锁服务要有递增的版本号version
  - 每次更新数据的时候都必须先判断版本号对不对，然后再写入新的版本号
#### 悲观锁
- 基于数据库排他锁做分布式锁
  - 在查询语句后面增加for update
  - InnoDB 引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁
  
### 基于Redis的分布式锁
- 加锁
  - SET key value NX  PX 100：key不存在时才设置，而且存活时间为100ms
  - 旧版
    - SETNX(key, value)成功则返回1，失败则返回0
    - expire()设置失效时间避免死锁
- 释放锁：delete删除key
- 集群模式：采用Redis的Redlock机制
- 问题
  - setnx expire非原子性，使用新版本的set
  - A线程超时误删B线程的锁：使用当前线程ID作为value，删除前判断是否为自己的线程的ID
    - 判断和释放非原子性：使用Lua脚本实现
    - 并发访问：守护线程给快要过期的锁续航，执行完后显式关闭守护线程

### 基于ZooKeeper实现
- 使用ZooKeeper的**临时有序节点**来实现
- 加锁
  - 在某个指定节点的目录下，去生成一个**唯一的临时有序节点**
  - 判断自己是否是这些有序节点中**序号最小的一个**
    - 如果是，则算是获取了锁
    - 如果不是，在序列中找到比自己小的那个节点，并对其调用**exist()**方法，对其**注册事件监听**(watch)，当监听到这个节点被删除了，那就尝试重新获取锁(再去判断一次自己当初创建的节点是否变成了序列中最小的)
- 释放锁
  - 删除临时节点
- Apache Curator包含了对Zookeeper分布式锁的实现

### 其他
- 本质原理：利用一个互斥访问的公共资源来实现
- 其他实现方法：
  - Chubby
  - Memcached add命令，只有ke不存在时才能add成功
