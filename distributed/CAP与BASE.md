### CAP
- Consistency(一致性), 数据一致更新，所有数据变动都是同步的
  - 强一致性：数据更新成功后，任意时刻所有副本中的数据都是一致的，一般采用同步的方式实现，会牺牲可用性
    - 2PC方案：提交分阶段 \+ 记日志的方式记录下事务提交所处的阶段状态，在组件宕机重启后，可通过日志恢复事务提交的阶段状态，并在这个状态节点重试
    - 2PC方案问题：同步阻塞、数据不一致、单点问题。2PC是反模式，尽量不要使用2PC，使用BASE来回避
    - 3PC方案的改进：增加超时机制、两阶段之间插入准备阶段
    - 避免数据不一致： Paxos 或者 Raft 算法
  - 弱一致性：数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承诺具体多久之后可以读到
  - 最终一致性：所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态
- Availability(可用性), 好的响应性能
- Partition tolerance(分区容忍性) 可靠性
- 定理：任何分布式系统只可同时满足二点，没法三者兼顾。一般网络认为不可靠，即分区容错无法避免，即认为P总是成立。因此，C和A无法同时做到

### BASE
- Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）
- 核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）
- 基本可用：分布式系统在出现不可预知故障的时候，允许损失**部分**可用性，比如响应变慢、部分功能损失
- 软状态：允许系统中的数据存在**中间状态**，并认为该中间状态的存在不会影响系统的**整体可用性**，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时
- 最终一致性(弱一致性的特例)有多个变种
  - 因果一致性：如果Process A通知Process B它已经更新了数据，那么Process B的后续读取操作则读取A写入的最新值，而与A没有因果关系的C则可以最终一致性。
  - “读己之所写（read-your-writes）”一致性：如果Process A写入了最新的值，那么Process A的后续操作都会读取到最新值。但是其它用户可能要过一会才可以看到
  - 会话（Session）一致性：执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。要求客户端和存储系统交互的整个会话阶段保证Read-your-writes consistency。Hibernate的session提供的一致性保证就属于此种一致性。
  - 单调（Monotonic）读一致性：要求如果Process A已经读取了对象的某个值，那么后续操作将不会读取到更旧的值
  - 单调写一致性：系统会序列化执行一个Process中的所有写操作
- 实现
  - 按功能划分数据库 
  - sharding碎片
  
### I/O的五分钟法则
- 如果一条记录频繁被访问，就应该放到内存里，否则的话就应该待在硬盘上按需要再访问。这个临界点就是五分钟

### JTA
- 提供了分布式事务的解决方案，严格的ACID
- 事务补偿机制: 在事务链中的任何一个正向事务操作, 都必须存在一个完全符合回滚规则的可逆事务
