### 事务
- 数据库管理系统执行过程中的一个逻辑单元，它能够保证一个事务中的所有操作要么全部执行，要么全不执行
- ACID

### 分布式事务典型场景
- 跨库事务
- 分库分表(水平拆分)
- 服务化，一个业务逻辑调用多个服务

### 2PC
- **准备阶段**
  - 协调者(Coordinator)向事务的参与者（Cohort）询问是否可以执行操作的请求，并等待其他参与者的响应
  - 参与者会**执行相对应的事务操作**并**记录重做和回滚日志**
  - 所有执行成功的参与者会向协调者发送**AGREEMENT**或者**ABORT**表示执行操作的结果
- **提交阶段**
  - 当所有的参与者都返回了**确定的结果**（同意或者终止）时，两阶段提交就进入了提交阶段，协调者会根据投票阶段的返回情况向所有的参与者发送**提交**或者**回滚**的指令
  - 当有参与者决定 ABORT 当前事务时，协调者会向事务的参与者发送回滚请求，参与者会根据之前执行操作时的回滚日志对操作进行回滚并向协调者发送完成的消息
  - 无论如何，都会释放资源
- 问题
  - 同步阻塞：所有参与事务的逻辑均处于阻塞状态
  - 单点：协调者存在单点问题，如果协调者出现故障，参与者将一直处于锁定状态
  - 脑裂：在阶段2中，如果只有部分参与者接收并执行了Commit请求，会导致节点数据不一致

### 3PC
- **CanCommit**
  - 协调者向所有参与者发出包含事务内容的CanCommit请求，询问是否可以提交事务，并等待所有参与者答复。
  - 参与者收到CanCommit请求后，如果认为可以执行事务操作，则反馈YES并进入预备状态，否则反馈NO。
  - 任何一个参与者反馈NO，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务
- **PreCommit**
  - 同2PC的准备阶段，但是增加了超时
- **do Commit**
  - 同2PC的提交阶段，但是增加了超时
- 问题：
  - 脑裂仍然存在，解决一致性问题，只有Paxos


### JTA
- 两阶段型事务
- 提供了分布式事务的解决方案，严格的ACID
- 事务补偿机制: 在事务链中的任何一个正向事务操作, 都必须存在一个完全符合回滚规则的可逆事务

### 柔性事务
- 定义
  - 满足ACID的事务成为刚性事务
  - 满足BASE理论的为柔性事务
- 分类
  - 两阶段型
  - 补偿型
  - 异步确保型
  - 最大努力通知型
  
### 幂等性
- 任意多次执行所产生的影响均与一次执行的影响相同
- HTTP方法的幂等性：同一个请求，发送一次和发送N次效果是一样的
  - GET方法用于获取资源，不应有副作用，所以是幂等的
  - DELETE方法用于删除资源，有副作用，但它应该满足幂等性
  - POST方法用于创建资源，所对应的URI并非创建的资源本身，而是去执行创建动作的操作者，有副作用，不满足幂等性
  - PUT方法用于创建或更新操作，所对应的URI是要创建或更新的资源本身，有副作用，它应该满足幂等性

### TCC
- 补偿型事务，本质也是两阶段型事务
- 核心思想：针对每个操作，都要注册一个与其对应的**确认**和**补偿（撤销）**操作
- JTA为资源层事务，TCC为服务层事务
- Try：尝试执行业务，对业务系统做**检测**及**资源预留**
  - 完成所有业务检查(一致性)
  - 预留必须业务资源(准隔离性)
- Confirm:确认执行业务
  - 真正执行业务
  - 不作任何业务检查
  - 只使用Try阶段预留的业务资源 
  - Confirm操作要满足幂等性
- Cancel: 取消执行业务，如果Confirm失败，则回滚并释放资源
  - 释放Try阶段预留的业务资源
  - Cancel操作要满足幂等性
- 优点： 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些
- 缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理

### XA Transactions
- prepare：询问每个RM是否可以提交事务
- commit：提交每个RM上的事务分支
- rollback：回滚每个RM上的事务分支
- 与TCC区别
  - A是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁
  - TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁
- 问题：
   - 单点问题
   - 同步阻塞：不支持高并发
   - 数据不一致

### 本地消息表(异步确保)
- 业界使用最多的，遵循了BASE理论，采用了最终一致性。即不会出现像2PC那样复杂的实现(当调用链很长的时候，2PC的可用性是非常低的)，也不会像TCC那样可能出现确认或者回滚不了的情况
- 在不需要强一致性的业务场景下，都可以通过**定时任务+幂等操作**来实现最终一致性
- 核心思想是将**分布式事务拆分成本地事务进行处理**
- 举例，订单系统支付成功后需要更新订单和扣减库存：
  - 在订单库里新增一个更新库存**消息表**，更新订单状态，插入一条**待确认**的记录到消息表(**消息表和业务数据要在一个事务里提交**，也就是说他们要在一个数据库里面)。消息表中的记录的orderID为支付成功的订单ID
  - 库存库中也新增一个出库表，**在一个事务中**更新商品库存，插入出库表
  - 更新库存消息表的状态为**已确认**
  - 后台**定时轮询本地消息表**中**待确认**的消息
    - 首先调用接口判断该消息中的订单是否存在于出库单中（消息中有订单ID，出库单中也有订单ID）
    - 如果不存在则并调用接口更新商品库存、插入出库单，更新消息状态为已确认；如果更新消息失败，继续上一步操作
    - 如果存在，则将消息状态更新为已确认，如果这一步中更新消息失败，回到第一步
- 缺点：消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理

### 事务消息(RocketMQ)
- 第一阶段Prepared消息，会拿到消息的地址
- 第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态
- 说在业务方法内要向消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了RocketMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认，所以生产方需要实现一个check接口，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。
