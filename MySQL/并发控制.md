## MVCC(多版本并发控制)
- 前提：在实际环境中数据库的事务大都是只读的，读请求是写请求的很多倍，如果写请求和读请求之前没有并发控制机制，那么最坏的情况也是读请求读到了已经写入的数据，这对很多应用完全是可以接受的
- 通过**保存数据在某个时间点的快照**来实现，不同存储引擎的MVCC实现是不同的，典型的有乐观并发控制和悲观并发控制
### InnoDB的MVCC
- 通过在每行记录后面保存两个隐藏的列来实现的,这两个列，分别保存了这个行的创建时间，一个保存的是行的删除时间。不是真正的时间，而是系统版本号，每开始一个新的事务，版本号递增，因此时间可理解为事务的ID
- SELECT
  - 行的**创建时间**早于当前事务版本的数据行，确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的
  - 行的**删除时间**要么未定义，要么大于当前事务版本号，确保事务读取到的行，在事务开始之前未被删除
- DELETE
  - 为删除的每一行保存当前系统的版本号(事务的ID)作为删除标识
- UPDATE
  - **实际上是新插入了一行记录**，并保存其**创建时间**为当前事务的ID，同时保存当前事务ID到要UPDATE的行的**删除时间**
### 配合UNDO来实现事务隔离


### 悲观并发控制
- 通过锁来解决
- 两阶段锁协议(2PL)
  - 增长阶段(Growing)只能获得锁，缩减阶(Shrinking)只能释放锁
  - 2个变种
    - Strict 2PL：事务持有的互斥锁必须在提交后再释放
    - Rigorous 2PL：事务持有的所有锁必须在提交后释放
  - 会引入死锁问题
### 乐观并发控制
- 基于时间戳的协议：每一个事务都会具有一个全局唯一的时间戳，它即可以使用系统的时钟时间，也可以使用计数器，只要能够保证所有的时间戳都是唯一并且是随时间递增的就可以
- 基于验证的协议：CAS加测读阶段是否更新了数据
### MVCC(多版本并发控制)

- MySQL 中实现的多版本两阶段锁协议（Multiversion 2PL）将 MVCC 和 2PL 的优点结合了起来，每一个版本的数据行都具有一个唯一的时间戳
  - 当有读事务请求时，数据库程序会直接从多个版本的数据项中具有最大时间戳的返回。
  - 更新操作：事务会先读取最新版本的数据计算出数据更新后的结果，然后创建一个新版本的数据，新数据的时间戳是目前数据行的最大版本 \＋1
  - 删除：会将**版本最低**的数据**定时**从数据库中**清除**以保证不会出现大量的遗留内容
