## 大方向
- 优化服务器内核(由运维完成)
- 对MySQL的配置参数(my.cnf)进行优化，需要进行压力测试来进行参数调整
- 语句优化及表优化

## 参数优化
- 默认最大连接数`show variables like 'max_connections';`
- 查看当前访问Mysql的线程`show processlist`
- 设置最大连接数`set globle max_connections = 5000;`
- 查看当前被使用的connections `show globle status like 'max_user_connections'`

## 表优化
- 尽量小而精，字段尽量少
- 能用数字类型就不要用字符串类型
- 尽量避免null，null不方便查询优化，复合索引失效。
- 图片等不要存DB，放到fastdfs中
- UNSIGNED表示不允许负值，大致可以使正数的上限提高一倍。比如TINYINT存储范围是-128 ~ 127，而UNSIGNED TINYINT存储的范围却是0 - 255
- 没有太大的必要使用DECIMAL数据类型。即使是在需要存储财务数据时，仍然可以使用BIGINT。比如需要精确到万分之一，那么可以将数据乘以一百万然后使用BIGINT存储。这样可以避免浮点数计算不准确和DECIMAL精确计算代价高的问题。
- TIMESTAMP使用4个字节存储空间，DATETIME使用8个字节存储空间。因而，TIMESTAMP只能表示1970 - 2038年，比DATETIME表示的范围小得多，而且TIMESTAMP的值因时区不同而不同
- 大多数情况下没有使用枚举类型的必要，其中一个缺点是枚举的字符串列表是固定的，添加和删除字符串（枚举选项）必须使用ALTER TABLE（如果只只是在列表末尾追加元素，不需要重建表）

## 优化误区
- 说把可为NULL的列改为NOT NULL不会对性能提升有多少帮助，只是如果计划在列上创建索引，就应该将该列设置为NOT NULL。
- 对整数类型指定宽度，比如INT(11)，没有任何作用
- 大表ALTER TABLE非常耗时，MySQL执行大部分修改表结果操作的方法是用新的结构创建一个张空表，从旧表中查出所有的数据插入新表，然后再删除旧表

## 语句优化
- 不要用select(*)，尽量加上limit
- 事务不能太大，否则不仅影响性能，还可能内存溢出
- update时where尽量走索引，不然会全表扫描(1G最少锁定10s）
- or尽量不用，改成in
- where里面不同字段or改成union `select a from A where b=1 union select a from A where c=1`
- 避免用count(*)，使用缓存或者单独的表来维护
- 避免"%s前缀"查询，会导致索引失效
- 尽量不用INSERT SELECT，数据量大有延迟，同步完了可能有错误
- UNION ALL而非UNION
- 分页时，`Select a from A limit 10000,10;`这种大偏移量效率低，
  - select a from A WHERE id\>=xxxx limit 11;(将上一页的最大值通过where id\> 进行预处理，然后分页)
  - select a from A WHERE id \>= ( select a from A limit 10000,1 ) limit 10;
  - select a from A inner join (select a from A limit 10000,10) using (id);


## 查询缓存
- 检查缓存在解析之前进行，如果有缓存，则查询不会被解析，也不会生成执行计划
- 如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果都不会被缓存
- 表(结构或者数据)发生变化，缓存都会失效
- 写密集型应用不要打开查询缓存，缓存会一直检查和刷新，增加消耗

## 查询优化器
- 作用
  - 重新定义表的关联顺序（多张表关联查询时，并不一定按照SQL中指定的顺序进行，但有一些技巧可以指定关联顺序）
  - 优化MIN()和MAX()函数（找某列的最小值，如果该列有索引，只需要查找B+Tree索引最左端，反之则可以找到最大值）
  - 提前终止查询（比如：使用Limit时，查找到满足数量的结果集后会立即终止查询）
  - 优化排序
- 优化之后，生成执行计划，为每张表生成一个handler实例
