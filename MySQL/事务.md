- 定义：一个操作序列，要么都执行，要么都不执行
## 四大特性
- 原子性Atomicity：不可分割
  - 回滚日志(undo log)实现回滚，所有事物进行的修改新纪录到回滚日志然后真正写入
    - 回滚日志还可用于系统崩溃数据库进程被杀死后重启数据库回滚事物，方式可以简单理解为反向操作
  - 并行事物的原子性：没有隔离性导致不可恢复安排，使用级联回滚解决，但会导致大量的工作需要撤回
- 一致性Consistency
  - 数据完整性约束：比如主键约束不会被违背
  - 逻辑正确性：比如入账出账操作是不会有总资金的变化的
- 隔离性Isolation：多个事务并发访问时，事务之间不相互影响。
- 持久性Durability：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚
  - 通过重做日志(redo log)来实现，分为两部分：内存中(易失)和硬盘(持久)
    - InnoDB中，重做日志为512B，与磁盘扇区大小相同，保证了原子性
    - 修改数据库和**回滚日志**都会创建重做日志
## 事务日志
- 本质上由回滚日志和重做日志来实现
- 理解：事务ID \+ 修改的行元素 \+ 旧值 \+ 新值
## 事务间的相互影响
- 脏读dirty read：一个事务读取了另一个事务未提交的数据
- 不可重复读unrepeatable read:一个事务范围内多次读取的结果不同，原因是查询时有其它事务提交
- 幻读phantom read：第二个事务插入或删除一条数据，这个数据本应该是第一个事务读取到的，但是因为第二个事务紧接着第一个事务完成后才完成，导致了第一个事务没有读到这一条，好像出错了一样
- 丢失更新lost update：两个事务同时操作一行，会有覆盖的情况
## 隔离级别
- 读取未提交Read Uncommited：可能出现所有问题
  - 使用查询语句不会加锁
- 读取已提交Read commited：解决脏读
  - 只对记录加记录锁，而不会在记录间加间隙锁，新的记录允许插入到锁定记录的附近
- 可重复读Repeatable Read：解决不可重复读和丢失更新，mysql默认隔离级别为REPEATABLE
  - 多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行
- 串行化Serializable：解决所有问题
  - 隐式地将全部的查询语句加上共享锁
- 以上隔离级别都不允许脏写入(Dirty Write)，也就是当前事务更新了另一个事务已经更新但是还未提交的数据
### 隔离级别的实现
- 锁(MySQL)
  - 共享锁：读锁
  - 互斥锁：写锁
  - MySQL读时默认不加锁(即默认为**快照读**)，除非显示加 `select ... FOR UPDATE`(**当前读**)
- 时间戳:PostgreSQL
- 多版本和快照隔离
  - MySQL和PostgreSQL都实现了这机制，即MVCC，比如MySQL通过回滚日志实现了MVCC，保证事务并行执行时能够不等待互斥锁的释放直接获取数据
  
### 锁
- InnoDB行锁是通过给索引上的索引项加锁来实现的，因此InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁
