### 原理
- Undo log：为了满足原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo Log）
  - 更新数据前记录Undo log
  - 为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化
  - Undo log必须先于数据持久化到磁盘
  - 如果在Undo log持久化到磁盘之前系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态.
- Redo log：和Undo Log相反，Redo Log记录的是**新数据的备份**。在事务提交时，只要将Redo Log持久化即可
  - Redo log必须先于数据持久化到磁盘，保证事务的数据能被更新

### IO性能
- 增加了新的IO
- 系统第一次启动时就会将日志文件的空间完全分配，从而保证Redo Log文件在存储上的空间有更好的连续性。即**顺序追加**的方式记录日志
- **批量写入日志**，减少IO次数。日志并不是直接写入文件，而是先写入redo log buffer。
- **并发的事务共享Redo Log的存储空间**，它们的Redo Log按语句的执行顺序，依次交替的记录在一起，以减少Redo Log的IO次数。
  - 当一个事务将Redo Log写入磁盘时，也会将其他未提交的事务的日志写入磁盘。
- 只有追加的操作，事务需要回滚时，**回滚操作也记入Redo Log**

### InnoDB的恢复
- 未提交的事务和回滚了的事务也会记录Redo Log，因此需要特殊的处理
- 策略：重做所有事务包括未提交的事务和回滚了的事务，然后通过Undo Log回滚那些未提交的事务
- 特点：
  - 在重做Redo Log时，并不关心事务性
  - 写Redo Log之前将对应的Undo Log写入磁盘

### 日志的内容
- 物理的日志
  - 记录完整的Page
  - 记录Page中被修改的部分(page中的偏移、内容、长度)
  - 优缺点：
    - 恢复时完全不依赖**原页面**上的内容
    - 占用很大空间
- 逻辑的日志
  - 记录在关系(表)上的一个元祖操作(增删改)
  - 占用空间小
  - 需要处理部分执行的问题；需要处理操作的一致性问题
- InnoDB采用混合日志
  - 物理到page，将操作细分到页面级
  - page内采用逻辑的日志
    - 整个页面的操作是原子操作，不存在部分执行的问题
    - Double Write解决页面范围内的操作一致性问题
  - Double Write
    - 在覆盖磁盘上的数据前，先将Page的内容写入到磁盘上的其他地方
    - 然后再将Page的内容覆盖到磁盘上原来的数据
    - 会增加IO，但是批量写入会使得性能损失不超过10%
    
### Checkpoint
- 基础概念
  - 脏页(dirty page)：如果一个数据页在内存中修改了，但是还没有刷新到磁盘。这个数据页就称作脏页
  - 日志序列号(Log Sequence Number)：日志空间中每条日志的结束点，用字节偏移量来表示
- 原理
  - 假设在某个时间点，所有的脏页都被刷新到了磁盘上.这个时间点之前的所有Redo Log就不需要重做了。系统记录下这个时间点时**redo log的结尾位置**作为checkpoint。在进行恢复时，从这个checkpoint的位置开始即可
- 作用：避免从第一条Redo Log开始恢复

### 缓存池(Buffer Pool)
- 将存储在文件中的数据以页为单位映射到内存中
- Buffer pool内的页分为三种:
  - 未被使用的页(空白的buffer)
  - 净页，映射到了一个数据文件页，而且没有被修改过
  - 脏页，映射到了一个数据文件页，并且数据被修改过
