## 使用
- 执行语句xx
- 执行explain xx

## 结果分析
- id select_type table用于定位本行参数所对应的sql查询部分
- **id**: 查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序 
  - 相同id：执行顺序由上至下
  - 不同id：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
- select_type: 主要是用于区分普通查询、联合查询、子查询等复杂的查询
  - SIMPLE：简单的select查询，查询中不包含子查询或者union
  - PRIMARY：查询中包含任何复杂的子部分，**最外层**查询则被标记为primary
    - **select * from class where class_id in** (select class_id from student)
  - SUBQUERY：子查询中的第一个SELECT，与union做反理解
    - select * from class where class_id in (**select class_id from student**)
  - DEPENDENT SUBQUERY：子查询中的第一个SELECT，依赖于外部查询
    - SELECT o.storeorder_id, o.storeorder_sn,**(SELECT stores_name from ec_stores_info where stores_id=o.store_id) as stores_name** from ec_stores_order o
  - DERIVED：派生表的SELECT(FROM子句的子查询)，结果放在临时表中
    - select * from (**select class_id, class_name from class**)
  - UNION：若第二个select出现在union之后，则被标记为union；若union包含在from子句的子查询中，外层select将被标记为derived
    - select * from teachers union **select * from students**
  - UNION RESULT：从union表获取结果的select，即union语句的结果集
    - select * from class where class_id in (**select class_id from teachers union select class_id from students**)
  - DEPENDENT UNION：子查询union语句的第二个或后面的select
    - select * from class where class_id in (select class_id from teachers union **select class_id from students**)
- table：输出的行所引用的表
  - 有时table字段显示的并不是表名，而是 derived2 或 derived3 等等，derived x 代表的是id为x的查询所得的结果集
- **type**：访问类型
  - 一般，好的sql查询至少要达到range级别，最好能达到ref
  - 结果值好坏排序：**system > const > eq_ref > ref** > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > **range > index > ALL**
  - system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，可以忽略不计
  - const：根据**主键或唯一索引**只取出确定的一行数据。是最快的一种，比如将主键置于where列表中，mysql就能将该查询转换为一个const 
    - select * from table where **id=1**
  - eq_ref：唯一性索引扫描，从这个表读取一行，对于前面表格的每一行组合，连接字段使用主键或是唯一索引时被使用。
    - SELECT * FROM ref_table,other_table WHERE ref_table.**key_column**=other_table.column;
    - SELECT * FROM ref_table,other_table WHERE ref_table.**key_column_part1**=other_table.column AND ref_table.**key_column_part2**=1;
  - ref：与eq_ref相对，使用非唯一索引或非唯一索引前缀进行的查找，该连接方式可以在索引列范围查询（\< \= \>）时被使用
    - SELECT * FROM ref_table WHERE **key_column=expr**;
    - SELECT * FROM ref_table,other_table WHERE ref_table.**key_column**=other_table.column;
  - ref_or_null：连接的索引列中有null值，ref就会变成这个
    - SELECT * FROM ref_table WHERE key_column=expr OR key_column IS NULL;
  - index_merge：此连接类型表示使用索引合并优化。 在这种情况下，输出行中的键列包含使用的索引列表，key_len包含所使用索引的最长键部分列表
  - unique_subquery：替换了以下形式的一些IN子查询的eq_ref
    - value IN (SELECT primary_key FROM single_table WHERE some_expr)
    - unique_subquery只是一个索引查找函数，它可以完全替代子查询以提高效率
  - index_subquery：IN子查询，适用于非唯一索引
    - value IN (SELECT key_column FROM single_table WHERE some_expr)
  - range：只检索给定范围的行，使用一个索引来选择行，扫描部分索引。比较运算符以及BETWEEN、IN，用常量比较关键字列时，可以使用range
  - index：扫描全部索引树
  - ALL：扫描全表
  - NULL: 不用访问表或者索引，直接就能得到结果，如`select 1 from test where 1`
- possible_keys：查询时**可能**使用的索引
- **key**：实际使用的索引，NULL表示没有使用索引。如果使用了覆盖索引，则该索引值出现在key列中，不在possible_keys中。
- key_len：使用到的索引字段的长度，根据表定义计算得到的最大可能长度而不是实际使用的长度
- ref：显示哪个字段或常数与key一起被使用
- **rows**：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数
- **Extra**：不适合在其他字段中显示，但是十分重要的额外信息
