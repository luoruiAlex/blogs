### 索引
- 存储
  - InnoDB中`.ibd`文件存放索引和数据
  - MySQL的基本存储结构是**页**(每个页中有File Header、File tail、记录、**页目录**等数据)
  - 各个数据页可以组成一个**双向链表**
  - 每个数据页中的记录组成一个**单向链表**
  - 通过主键查找的时候可在页目录中用**二分法**快速定位到对应的槽，**遍历槽**即可快速找到记录
  - 非主键查找只能从最小记录开始依次遍历单链表中的每条记录
    - 遍历双向链表，找到所在的页
    - 遍历页中的单向链表
- B+树
  - 平衡树的一种(空树或者左右两个子树的高度值差不超过1，而且左右子树都是平衡二叉树)
- Hash索引
  - 不能排序
  - 不支持最左匹配原则
  - hash碰撞
  - 不支持范围索引
- 聚集索引与非聚集索引
  - 聚集索引
    - 主键创建的索引
    - 叶子节点中存储表中的数据
    - 一个表只能有一个聚簇索引，而且必须包含主键
  - 非聚集索引(二级索引)
    - 非主键创建的索引
    - 叶子节点中存储主键和索引列
    - 使用非聚集索引查询，拿到叶子上的主键再去查找想要查找的数据(回表)
    - 多个非聚集索引会创建多个索引树
    - **覆盖索引**：要查的列和索引时对应的，不用回表
- **索引最左匹配**
  - 用于联合索引，一直向右匹配知道遇到范围查询(>、<、between、like)
- 多个=、in的顺序不用考虑，MySQL会自动优化
- 自适应Hash索引
  - 用户不感知
  - InnoDB注意到某个索引被频繁使用时，在内存中建立再建立一个Hash索引
- 使用经验
  - 联合索引最左前缀原则，建立的时候区分度最高的字段放到最左边
  - 不要在列上调用函数或者进行运算
  - 负向条件查询不能使用索引(`!=、<>、not in、not exists、not like`)
  - 使用覆盖索引
  - 避免强制类型转换
  - 范围列(`> < >= <= between`)可以用到索引，但是范围列之后的列无法使用到索引
  - 索引不允许为空，否则可能得到不符合预期的结果集
  - 更新频繁和数据区分度不高的字段不易建立索引
  - 避免在where中使用or来连接条件，会使索引失效(新版MySQL中能命中索引，但是还是比IN慢)
  - 前导模糊查询不能用索引，非前导可以

### 锁
- UPDATE INSERT DELETE语句，InnoDB自动给涉及的数据集加排他锁
- 锁的粒度
  - 表锁(MyISAM只支持表锁)
    - 分为表读锁和表写锁，读写、写写都会阻塞
    - 写锁优先于读锁
  - 行锁
    - **InnoDB的行锁基于索引**(只有通过索引条件索引数据时采用行级锁)
    - `共享锁--读锁--S锁` `SELECT * FROM XX WHERE ... LOCK IN SHARE MODE`
    - `排他锁--写锁--X锁` `SELECT * FROM XX WHERE ... FOR UPDATE`
- 锁的策略
  - 乐观锁
    - 仅仅是一种策略，通过版本字段来CAS(update语句中匹配之前查到的version)
  - 悲观锁
    - 悲观锁会从数据库层面加锁
    - `select * from xxx for update`
- 间隙锁GAP
  - 用范围条件检索并请求锁的时候，InnoDB会给范围内的记录的索引加锁；同时对**范围内不存在**的记录也会加锁，即间隙锁
  - 间隙锁只会在Repeatable Read级别下使用
  - 目的
    - 防止幻读
    - 满足恢复和复制的要求：一个事务未提交前，其他并发事务不能插入其锁定条件的任何记录，即不允许出现幻读
- 避免死锁
  - 以固定的顺序访问表和行
  - 大事务拆小
  - 同一个事务中，尽量一次锁定所有需要的资源
  - 降低隔离级别
  - 为表添加合理的索引
- MVCC(多版本并发控制)
  - 在Read Committed和Repeatable Read下工作
  - 能实现读写不阻塞
