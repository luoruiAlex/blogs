## 行格式
- Compact、Redudant(MySQL5.0前的格式)、Dynamic(MySQL5.7)、Compressed
- 语句 `CREATE TABLE ... CHARSET=utf8 ROW_FORMAT=COMPACT`
- 行格式 = 记录的额外信息 + 记录的真实数据
### Compact
#### 记录的额外信息
- 变长字段长度列表
  - 数据类型占用的空间包括真正内容和占用的字节数
  - VARCHAR BARBINARY TEXT BLOB等类型
  - 逆序存放长度，有特定规则来计算用几个字节表示长度
  - 只存非NULL的的列内容所占用的长度
- NULL值列表
  - 每个允许NULL的列对应一个二进制位，逆序排列
  - NULL值列表用整数个的字节表示，不够的在高位补0
- 记录头信息
  - 由固定的5个字节组成
  - 包括是否删除标记、B+数算法标记、下一条记录的相对位置等信息
#### 记录的真实数据
- 隐藏列
  - 表没有主键时增加row_id(6字节)
  - transaction_id(6字节)
  - roll_pointer(7字节)
- 不再重复存储NULL
- Char(N)等定长的列不够长的用空格填充

## 行溢出
- 除了BLOB TEXT外其他所有的列(不含隐藏列和记录头信息)的长度加起来最多占用65535个字节
- VARCHAR，长度需要2字节，NULL值标识1字节，所以最多为65532，如果非ascii编码，长度会更短
- Compact、Redundant，对占用空间非常大的列，在记录的真实数据处存储 768字节数据 + 20字节其他页地址
- 行溢出临界点，一个页中最少存放2行记录以及一些元信息
- Dynamic和Compressed行格式行溢出时真实数据存储处智慧存其他页面的地址，Compressed还会把存到其他页面的数据进行压缩

## 数据页
- 申请页时，从Free Space部分开始，慢慢被User Records部分替换
- 双链表，有上一页和下一页的编号

## 记录头信息
- delete_mask 默认并未真正删除，后续插入可能直接覆盖，彻底删除应用`optimize table tablename`使服务器重新规划存储方式
- min_rec_mask
- n_owned
- heap_no表示记录在本页中的位置，通过比较主键的大小来比较记录的大小，每页中还有最大记录和最小记录两条伪记录(不在User Records部分)
- record_type 包括普通记录、B+树非野节点记录、最小记录、最大记录
- next_record 当前真实数据到下一条记录真实数据的地址偏移量(按主键从小到大)，即维护了一条记录的单链表

## 根据主键查找
- 生成页目录
- 通过二分法确定该记录所在的槽
- 通过记录的next_record组成的链表遍历查找记录

## 没有索引的查找
- 只能是遍历
- 先定位到页，**将整个页加载到内存中**，然后到页中遍历找记录。(内存操作，时间忽略)

## 索引
- B\+ 树索引并不能找到一个给定键对应的具体值，也只能先找到数据行对应的页
- B\+ 树是平衡树，它查找任意节点所耗费的时间都是完全相同的，比较的次数就是 B+ 树的高度
- InnoDB 存储引擎中的表都是使用索引组织的，也就是**按照键的顺序存放**，行记录不是按顺序存放
### 聚簇索引(clustered index)和辅助索引(secondary index)
- 聚簇索引：存放着一条行记录的全部信息
  - 以**id**为索引的键，并在**叶子节点**中存储一条记录中的**所有信息**
  - 正常的表应该**有且仅有一个**聚集索引
- 辅助索引：叶子节点只包含索引中的**所有键**和当前记录的**主键**

## 存储
- 结构体系
  - 表空间(tablespace)
    - 同一个数据库实例的所有表空间都有相同的页大小，数据交换以页为单位，默认为每页16KB，可通过innodb_page_size修改
  - 段(segment)
  - 区(extent)
  - 页(page)
- **表的定义**(\.frm)和**数据索引**(\.ibd)分开存储
- InnoDB 中用于存储数据的文件总共有两个部分，一是系统表空间文件，包括 ibdata1、ibdata2 等文件，其中存储了 InnoDB 系统信息和用户数据库表数据和索引，是所有表**公用**的，而ibd 文件是每一个表**独有**的表空间，存储了当前表的数据和相关的索引记录
- \.ibd：数据在InnoDB中按行存储，每页可存放2到200行的记录
- 页结构：User Records 就是整个页面中真正用于存放行记录的部分，而 Free Space 就是空余空间了，它是一个链表的数据结构，为了保证插入和删除的效率，整个页面并不会按照主键顺序对所有记录进行排序，它会自动从左侧向右寻找空白节点进行插入，**行记录在物理存储上并不是按照顺序的**，它们之间的顺序是由 next_record 这一指针控制的
