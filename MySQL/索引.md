## 为什么快
- 硬盘随机读取约10ms左右
- 硬盘顺序读取速度约为40MB/s，4KB的页可以读10000个，即一页约0.1ms，甚至比内存读还要快(1ms)
- 索引能避免二次的随机I/O

## 优缺点和使用原则
- 优点：可以给任意字段设置索引，大大加快数据的查询速度
- 缺点：创建和维护索引需要时间和空间，降低了维护数据的速度，索引文件可能比数据文件更快达到上限值
- 使用：经常更新、数据量小的表不要使用索引，不同值多的字段上不要建立索引

## 分类
### 单列索引
- 普通索引：允许索引列插入重复值和空值
- 唯一索引：不允许重复值(UNIQUE)
- 主键索引：不允许重复值，不允许为空(KEY)
### 组合索引
- 只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。比如id,name,age组成的索引，可索引(id,name,age)(id,name)(id)这几个字段组合
### 全文索引(FULLTEXT)
- 只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引
### 空间索引(SPATIAL)
- 引擎为MyISAM，创建空间索引的列，必须将其声明为NOT NULL。MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON

## 创建
- 创建表的时候创建索引
```
CREATE TABLE tablename {
fieldname FIELDTYPE
...
[UNIQUE|FULLTEXT|SPATIAL|PRIMARY|...] [INDEX|KEY] [indexname](fieldname[length]) [ASC|DESC]
};
```
- 在已存在的表上创建索引
```
ALTER TABLE tablename ADD [UNIQUE|FULLFLEX...] [INDEX|KEY] [indexname](fieldname[length]) [ASC|DESC]
```

## 删除
- `ALTER TABLE tablename DROP INDEX indexname`
- `DROP INDEX indexname ON tablename`

## 查询
- `SHOW INDEX FROM tablename[\G]` `\G`只是为了让输出更好看

## 测试(看查询是否使用了索引进行查询)
- `EXPLAIN select * from tbl where xxx\G`
- id: SELECT识别符，即该语句中SELECT是第几次出现
- select_type:SIMPLE表示为简单的SELECT，不实用UNION或子查询，就为简单的SELECT。也就是说在该SELECT查询时会使用索引。其他取值，PRIMARY：最外面的SELECT.在拥有子查询时，就会出现两个以上的SELECT。UNION：union(两张表连接)中的第二个或后面的select语句  SUBQUERY：在子查询中，第二SELECT
- table: 表名，按被读取的先后顺序排列
- type: 本数据表和其他表之间的关联关系，包括ref、system、eq_ref、index和all
- **possible_keys**： 可选用的索引
- **key**: 实际选用的索引
- key_len: 使用的索引的个数
- ref：给出关联关系中另一个数据表中数据列的名字
- rows: 预计会从这个数据表里读出的数据行的个数
- Extra: 提供了与关联操作有关的信息，没有则什么都不写


## B+树
- 只有叶子节点（leaf nodes）会指向行数据
- 叶子节点也不会直接存储行数据的位置，而是存储聚簇索引（clustered index）的值，通过聚簇索引去找到数据的位置
- 最左前缀匹配：B+树中复合索引按照定义的顺序依次比较寻找下一个节点
- 覆盖索引：当你select的字段里只有复合索引里的字段，那么where语句不需要满足最左前缀匹配，Mysql也会走索引
  - 当你拿到了一本书的目录，里头有标题和对应的页码，当你想知道第267页的标题是什么的时候，完全没有必要翻到267页去看，而是直接看目录
  - 除了索引中的字段外，还有聚簇索引的字段也会被覆盖
- 聚簇索引
  - 具有唯一性的字段，主键或者唯一索引
  - 顺序结构与数据存储物理结构一致
  - 除了聚簇索引，mysql中的其他索引，都叫二级索引（secondary index）
- 对比
  - 二叉树：左子树的值总是小于根的值，右子树的值总是大于根的值
  - 平衡二叉树(AVL)：任何节点的两个子树的高度差不能大于1。查询效率高，维护相对简单，但是每读一个节点就要一次硬盘I/O，数据大了性能低下
  - B+树：减少了AVL的深度，变为m叉树
- 特点
  - 所有关键字(数据)都存在叶子节点(Leaf Page)，非叶子节点(Index Page)不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上
  - 所有的叶子节点由指针连接(连成双向环)，好处是可以进行区间查找
  - 每个子节点的大小为一个页的整数倍，每个节点可以存储更多内节点
- 原理
  - 磁盘每次都会预读，预读的长度为页的整数倍。每个节点只需要一次I/O就可以完全载入
  - 假设B+Tree的高度为h，一次检索最多需要h-1I/O（根节点常驻内存），复杂度$O(h) = O(\log_{M}N)$。实际应用场景中，M通常较大，常常超过100，因此树的高度一般都比较小，通常不超过3。
  - 插入、删除：旋转、拆分来减少I/O

## 索引优化
- 不会使用索引的情况：非独立的列(表达式的一部分或者函数的参数)，比如`select * from a where id + 1 = 5`，但是把函数用在条件上，索引会生效｀select * from staff where birthdate < (to_date('01-MAY-82') + 0.9999);｀
- 前缀索引：如果列很长，通常可以索引开始的部分字符，这样可以有效节约索引空间，从而提高索引效率
- not in ，not exists ，（<> 不等于 ！=） 这些不走索引，< 小于 > 大于 <= >= 这个根据实际查询数据来判断，如果全盘扫描速度比索引速度要快则不走索引
- like abc%走索引而like %abc不走索引
- 使用 is null 或is nuo null也会限制索引的使用，因为数据库并没有定义null值
- 字符串列与数字直接比较不走索引，而数字列与字符串比较走索引
- 不等于的条件应改为**小于union大于**，但是，只有一个字段的话，数据库优化器会判断候选结果集是否超出了全部结果的 5%（估计），如果超过，那么就全表扫描。所以像> < in 这种操作，走不走索引要看本身可能的结果数量
- 多列索引和索引顺序，一般在多个列上建立了独立索引不能提高效率。应该把索引选择性(不重复率)更高的索引放在前面
  - 多索引AND一个复合索引比多个独立索引要好
  - 多索引OR 新版本的MySQL会优化成union，建议单列索引和多列索引都尽量使用union而不是or
